---
layout:     post
title:      "난 게임은 잘 못해."
subtitle:   "[JAVA] [AWT]"
date:       2013-12-23 12:00:00
author:     "SturdyEgg"
header-img: "img/post_poco/title.jpg"
---
 
 <!-- **[Github Link](https://github.com/deplax/)** -->

#Summary

|**Project name :** Poco
|**Language :** Java
|**Type of project :** Personal project
|**Project duration :** 2 week
|**Source code :** <a href="https://github.com/deplax/P_Poco" style="color:#3366FF; font-weight:bold">Github Link</a>

####Brief Description <br>
한 붓 그리기 모바일 게임을 블록을 인지하여 자동으로 풀었다.

<br/>


#Description

Treenod에서 개발한 *포코팡*이라는 게임이 있다. 한붓그리기 방식으로 같은 색상의 블록을 많이, 빠르게 이어 블록을 제거하는 게임이다. 난 게임을 잘 하지 못했고 대신 컴퓨터에게 이 게임을 가르치기로 했다. 실시간으로 블록의 색상을 감지하여 최적의 길을 찾아 블록을 제거하며, 필요한 시기에 아이템을 발동하도록 코딩하였다.

Java로 제작한 첫 번째 프로그램이지만 언어는 사실 수단에 불과했고 가장 큰 이슈는 “어떻게 하면 컴퓨터가 가장 긴 블록을 찾을 것인가?”와 “컴퓨터의 풀이를 어떻게 모바일 게임의 입력으로 넣을 것인가?”였다. 프로그래밍을 시작하기 위해서는 두 번째 문제를 먼저 해결해야했다. AVD 등을 사용해 보았지만 성능이 나오지 않아 적합하지 않았고 이대로 물러설 수 없어 조금은 꼼수를 부려보기로 했다. BlueStack이라는 프로그램에 포코팡을 설치하고 내 계정으로 로그인하면 PC에서 포코팡게임을 꾀나 쾌적하게 할 수 있었다. 이렇게 컴퓨터에서 마우스로 모바일게임이 가능하게 되었다.

이제 다음 문제는 로직을 짜서 BlueStack에 입력시키는 것이다. 한 블록은 6개의 블록과 인접하여 있었고 높은 점수를 위해서는 중복하지 않고 가장 길게 블록을 순회하는 것이다. 이 과정을 위해서는 블록의 식별이 필요했다. 빨간색인지 초록색인지, 아이템이나, 특수 블록은 아닌지 블록의 색상 범위에 따라 스캔하여 블록을 인식하여 배열에 저장했다. 저장된 블록은 한 방향으로만 탐색하도록 설정하여 총 블록의 수만큼 반복하였다.

이 과정이 끝나면 현재 상태에서 가장 긴 블록을 찾을 수 있었고, 그 블록의 위치를 배열에 저장하여 순서대로 그려주었다. 메커니즘 자체는 간단하지만 구현에는 많은 시행착오를 겪었다. 아무래도 Java를 처음 다루는 것과 안정적인 테스트가 불가능했기 때문이라 생각한다. 그렇게 난 주변사람들의 2배에 달하는 점수를 얻을 수 있었고 주변 사람들은 모두 이 게임을 접었다.

사실 형이 발로해도 이긴다고 해서 시작되었다.

<br/><br/>


#Postmortem

####어려웠던 점
* 사실 자바를 모른다.
: 자바를 SDK안에 있는 sample source를 보고 배웠다. 사정이 있어 제한된 환경에서 메모장만으로 자바를 배우다가 개인 PC에서 처음으로 eclipse를 설치하고 자바를 사용할 수 있게 되어 즐거웠던 기억이 난다. source만 보고 키워드의 역할을 추론해서 배웠기에 사실 이 프로그램을 완성될 당시까지 new라는 키워드의 역할을 몰랐다.
* 처음에는 사람보다 느렸다.
: 내부에서 블록을 풀어내는 알고리즘이 5번 정도 크게 바뀌었다. 일단 블록의 배치가 지그재그인 것부터 블록에서 다른 블록으로의 접근이 6곳이라는 점이 상황을 난감하게 만들었다. 작동하는 부분에만 신경쓰다보니 처음 작동한 프로그램은 사람이 푸는 것보다 현저히 느렸다. 
* 다른 프로그램에 의존
: 모바일 화면을 *Bluestack*이라는 프로그램을 통해 PC로 화면을 옮겨 그 화면을 인식하는 방식으로 작성하였다. 따라서 이 프로그램에 의존적일 수밖에 없었다. 또 테스트를 위해서는 게임을 한 번 구동해야 하는데 게임 한 판을 위해서는 게임 상의 클로버가 하나 소모되었다. 이 클로버는 최대 5개가 누적되며 테스트를 한번에 5번 이상은 할 수 없었다.

####잘된 점.
* 6방향을 한 붓 그리기로 어떻게 그릴까?
: 배열을 사용하였으나 어떻게 하면 한 붓 그리기를 할까? 고민이 많았다. 배열의 순회를 따로 처리하여 이 문제를 해결할 수 있었다. 6방향을 차례로 방문하기 위하여 x-1, x+1, x-w-1, x-w+1, x-w, x+w 이런 식으로 접근하여 방문하고 방문한 곳은 표기하였다. 블록마다 모든 방문을 마치고 가장 길이가 긴 것을 계산하여 블록을 터뜨리면 가장 높은 점수를 얻을 수 있었다.
* 개선, 개선, 개선
: 사람보다 느린 컴퓨터의 문제풀이는 내부 알고리즘을 3번째로 크게 뒤엎었을 때 해결되었다. 자바라는 언어자체가 생소한 단계에서 개선을 반복하여 처음의 목표를 뛰어넘어 달성하였다.
* 나름대로의 메커니즘
: 내 나름대로의 논리를 내 나름대로 코드로 옮기는 과정이 반복되었다. '어떻게 이 블록이 무슨 색상인지 인식 할 수 있을까?' 그저 색만 추출하면 같은 블록으로 인식될 줄 알았지만 1 pixel을 가져왔을 때 언제나 같은 색상이 잡히지 않았다. 한 블록에서 5개의 색상을 추출하고 어느 색상의 블록인지 감지하도록 하였다.

<br/><br/>


#Preview video
<iframe src="https://www.youtube.com/embed/KgwcdsXPnfc" frameborder="0" allowfullscreen></iframe>
